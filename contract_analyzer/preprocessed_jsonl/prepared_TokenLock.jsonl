{"original_clause_or_definition": "constructor() {\n        authorized[msg.sender] = true;\n    }", "risk_level": "Low", "summary": "This constructor function executes only once when the smart contract is deployed. It initializes a mapping named `authorized` by setting the deployer's address (`msg.sender`) to `true`. This is a common pattern to establish the contract deployer as an initial administrator or owner, granting them specific privileges within the contract.", "key_terms_operations": ["constructor()", "authorized", "msg.sender", "mapping initialization", "contract deployment"]}
{"original_clause_or_definition": "function allow(address user) external auth {\n        authorized[user] = true;\n    }", "risk_level": "Medium", "summary": "This function allows a privileged entity (whose access is controlled by the 'auth' modifier) to grant authorization to a specific user address. It sets the entry for the given 'user' in the 'authorized' mapping to 'true', typically used for access control, whitelisting, or role management within the contract. The risk level is medium because while the 'auth' modifier restricts who can call it, a compromise of the 'auth' role could lead to unauthorized granting of permissions.", "key_terms_operations": ["function allow(address user)", "external", "auth (modifier)", "authorized[user] = true", "address user", "authorization/access control"]}
{"original_clause_or_definition": "function deny(address user) external auth {\n        authorized[user] = false;\n    }", "risk_level": "Medium", "summary": "This function allows an authorized entity (as defined by the `auth` modifier) to revoke the authorization status of a specified user. It sets the `authorized` status for that user to `false`, effectively denying them access or privileges within the contract. While protected by access control, the power to deny access is significant and could lead to denial of service for legitimate users if the `auth` role is compromised or misused.", "key_terms_operations": ["deny", "address user", "external", "auth (modifier)", "authorized[user] = false (state modification)", "authorized (implied mapping)"]}
{"original_clause_or_definition": "function get(address token) external view returns (Lock memory) {\n        return locks[token];\n    }", "risk_level": "Low", "summary": "This is a public, read-only function that allows any external caller to retrieve the 'Lock' struct associated with a given 'token' address from the 'locks' mapping. It serves as a simple getter for stored lock information, providing transparency into the state of individual token locks.", "key_terms_operations": ["function get", "address token", "external view", "returns (Lock memory)", "locks[token]", "mapping lookup"]}
{"original_clause_or_definition": "function set(address token, uint32 duration) external auth {\n        locks[token].duration = duration;\n    }", "risk_level": "Medium", "summary": "This function allows an authorized entity (as enforced by the `auth` modifier) to set or update the 'duration' associated with a specific token within the contract's 'locks' mapping. This 'duration' likely defines a lock-up period, vesting schedule, or some other time-based parameter for that token. While access is restricted to authorized callers, changes to this value could significantly impact future or even existing token lock-up terms, potentially altering fund accessibility or vesting schedules. If this change affects existing locks retroactively, the risk level would be High.", "key_terms_operations": ["set (function)", "token (address parameter)", "duration (uint32 parameter)", "external (visibility)", "auth (access control modifier)", "locks (mapping, implied data structure)", "assignment (locks[token].duration = duration)", "lock-up period / vesting schedule (conceptual impact)"]}
{"original_clause_or_definition": "function unlocked(address token) public view returns (uint256) {\n        Lock memory l = locks[token];\n        // block.timestamp >= expiresAt >= updatedAt\n        // block.timestamp >= updateAt >= expiresAt\n        if (block.timestamp >= l.expiresAt) {\n            return l.amount;\n        }\n        // expiresAt > block.timestamp >= updateAt\n        return l.amount * (block.timestamp - uint256(l.updatedAt))\n            / uint256(l.expiresAt - l.updatedAt);\n    }", "risk_level": "Medium", "summary": "This `view` function calculates the amount of tokens that are currently unlocked from a time-based lock. It implements a linear vesting schedule: if the current block timestamp is past or equal to the `expiresAt` timestamp, the full `l.amount` is returned. Otherwise, a proportional amount is calculated based on the elapsed time since `l.updatedAt` relative to the total lock duration (`l.expiresAt - l.updatedAt`). A critical vulnerability exists if `l.expiresAt` is equal to `l.updatedAt`, which would lead to a division-by-zero error, causing the transaction to revert.", "key_terms_operations": ["block.timestamp", "Lock memory l", "l.expiresAt", "l.updatedAt", "l.amount", "Linear vesting calculation", "Integer division", "Division by zero (potential error)"]}
{"original_clause_or_definition": "function claimable(address token) public view returns (uint256) {\n        return freed[token] + unlocked(token);\n    }", "risk_level": "Low", "summary": "This `public view` function calculates and returns the total amount of a specified `token` that is currently available for claiming. It achieves this by summing a pre-determined 'freed' amount (likely stored in a mapping `freed`) with a dynamically calculated 'unlocked' amount (obtained by calling the `unlocked` function for that token). As a `view` function, it does not modify the contract's state.", "key_terms_operations": ["claimable", "address token", "uint256", "public view", "freed[token]", "unlocked(token)", "+"]}
{"original_clause_or_definition": "function lock(address token, uint256 amount) external auth {\n        uint256 free = unlocked(token);\n\n        Lock storage l = locks[token];\n        l.amount -= free;\n        l.updatedAt = uint32(block.timestamp);\n        l.expiresAt = uint32(block.timestamp) + l.duration;\n        freed[token] += free;\n\n        if (amount > 0) {\n            IERC20(token).transferFrom(msg.sender, address(this), amount);\n            l.amount += amount;\n        }\n    }", "risk_level": "Medium", "summary": "This function, callable only by an authorized entity, manages a token lock. It first calculates and deducts an 'unlocked' amount from the internal locked balance for a specific token. It then updates the lock's `updatedAt` timestamp and *resets* its `expiresAt` timestamp to the current block time plus a predefined `duration`. If a positive `amount` is provided, it transfers those tokens from the caller to the contract and adds them to the internal locked balance. The key implication is that each call to this function effectively extends or resets the lock duration from the current time, rather than adding to an existing lock period.", "key_terms_operations": ["auth modifier", "unlocked(token) (external dependency)", "Lock storage l = locks[token] (state access)", "l.amount -= free (deduction from locked balance)", "l.updatedAt = uint32(block.timestamp) (timestamp update)", "l.expiresAt = uint32(block.timestamp) + l.duration (lock extension/reset)", "freed[token] += free (accounting for freed tokens)", "IERC20(token).transferFrom(msg.sender, address(this), amount) (token transfer)", "l.amount += amount (addition to locked balance)"]}
{"original_clause_or_definition": "function unlock(address token) external auth returns (uint256 amount) {\n        uint256 free = unlocked(token);\n\n        Lock storage l = locks[token];\n        l.amount -= free;\n        l.updatedAt = uint32(block.timestamp);\n\n        amount = freed[token] + free;\n        freed[token] = 0;\n\n        if (amount > 0) {\n            IERC20(token).transfer(msg.sender, amount);\n        }\n    }", "risk_level": "Medium", "summary": "This function allows an authorized user to withdraw available tokens from a time-locked or vesting contract. It first calculates the currently 'unlocked' amount (likely based on a vesting schedule or time elapsed), then updates the contract's internal state by reducing the total locked balance and recording the timestamp of the withdrawal. It aggregates any previously 'freed' but untransferred amounts with the newly unlocked amount, resets the 'freed' balance, and finally transfers the total calculated amount of tokens to the caller. The security of this function heavily depends on the correct implementation of the `unlocked(token)` calculation and the robustness of the `auth` access control modifier.", "key_terms_operations": ["unlock function", "auth modifier (access control)", "unlocked(token) (vesting/unlock calculation)", "Lock storage (state management for locked tokens)", "l.amount -= free (reduction of locked balance)", "l.updatedAt = uint32(block.timestamp) (timestamp update)", "freed[token] (mapping for previously freed amounts)", "IERC20(token).transfer (ERC20 token transfer)", "Checks-Effects-Interactions pattern (state changes before external call)"]}
{"original_clause_or_definition": "function sync(address token) external auth {\n        uint256 reserved = freed[token] + locks[token].amount;\n        uint256 bal = IERC20(token).balanceOf(address(this));\n        if (bal > reserved) {\n            IERC20(token).transfer(msg.sender, bal - reserved);\n        }\n    }", "risk_level": "Medium", "summary": "This function allows an authorized caller (controlled by the `auth` modifier) to withdraw any ERC-20 token balance held by the contract that exceeds the internally tracked 'reserved' amount. The 'reserved' amount is calculated as the sum of `freed[token]` and `locks[token].amount`. If the contract's actual balance of a given token is greater than this calculated reserved amount, the excess is transferred to the caller (`msg.sender`). This function aims to prevent funds from getting permanently stuck in the contract while ensuring that only truly excess funds are withdrawn.", "key_terms_operations": ["sync (function)", "auth (modifier)", "freed (state variable/mapping)", "locks (state variable/mapping)", "reserved (calculated value)", "IERC20.balanceOf()", "IERC20.transfer()", "msg.sender", "address(this)"]}
